Документација читавог пројекта налази се у овом директоријуму. Ради боље прегледности, документи специфични за сам пројекат и фазе израде пројекта стављени су у посебан поддиректоријум *"projekat"*.

# Пројекат "AI Playground"

Као што само име каже, овај пројекат представља "игралиште" за "вештачку интелигенцију" односно симулатор у коме корисници могу да програмирају ботове који се потом надмећу у одређеним активностима. Битно је напоменути неке од карактеристика овог пројекта и шта је то што разликује овај пројекат од сличних покушаја да се овако нешто направи:

* Симулатор је потпуно детерминистачан. То значи да може да се покрене у било ком тренутку и на било ком уређају и резултат симулације ће сваки пут бити идентичан за исте почетне услове. Понашање ботова је потпуно детерминисано скриптом коју корисници пишу и након почетка симулације нико са стране не утиче на симулацију, већ се она одвија по тачно дефинисаним правилима.
* Могуће је изабрати програмски језик скрипте. Сваки корисник може скрипту писати у произвољном програмском језику, а сви ботови могу бити у истом симулатору. О детаљима биће више речи у поглављу *"Програмски језик"*.
* Равноправност извршавања. Све корисничке скрипте извршавају се са равноправно расподељеним временом. Расподела извршавања инструкција сваке корисничке скрипте је прецизно дефинисана и не зависи од оперативног система нити било ког непредвидивог фактора.
* Безбедност. Симулатор је безбедан од напада. Не постоји могућност да неко напише скрипту која ће приступити ресурсима оперативног система сервера, нити која ће ометати правилно функционисање сервера ни на који начин.
* Серијализабилност. Симулацију је у било ком тренутку могуће паузирати, серијализовати у низ бајтова и сачувати негде, а исто тако је могуће из низа бајтова десеријализовати симулатор тако да он настави са извршавањем и да то буде потпуно транспарентно за корисничке скрипте. Низ бајтова који представља резултат серијализације садржи све потребне информације о стању симулације, што значи да није потребно чувати никакве додатне референце у оперативној меморији. Другим речима, могуће је послати тај низ бајтова на другу машину, десеријализовати и наставити симулацију, а резултат ће бити идентичан.
* Адаптибилност. Ентитети и други објекти у симулатору у стању су да међусобно интерагују базирајући се само на скупу особина које познају или које су им од интереса. Ово омогућава додавање великог броја различитих ентитета, хијерархијски распоређених по типовима и скуповима особина које поседују, а да притом не постоји опасност да ће интеракција било која два ентитета проузроковати неку грешку или пад сервера.
* Релативизам. Објекти нису свесни апсолутних координата света нити правца у који су окренути. Они све виде релативно у односу на своју позицију и оријентацију.

## Фрејмворкови

Постоје три главна фрејмворка која се користе у овом пројекту:

1. Omikron
2. Simulator
3. ProgLang

### Omikron

Садржи велики број функција и класа које се често користе у другим пројектима. Најзначајнија класа је *"Serializer"* која је задужена за серијализацију и десеријализацију података. Подаци се уписују као низ битова, могу се уписивати секвенце битова, цели бројеви (означени и неозначени), реални бројеви (са стандардном и двоструком прецизношћу), стрингови, итд. Резултат је низ бајтова (додају се 0-битови на крају ако нема довољно битова да се формира бајт). У процесу десеријализације битно је знати који формат и који подаци се налазе у низу бајтова, јер не постоје никакве провере типова. Постоји посебан механизам *"checksum"* који штити излазни низ бајтова од оштећења и гарантује конзистентност.

### Simulator

Симулатор се састоји од тродимензионе мреже коцака. Свет је неограничен у свим правцима. Координате су следеће: ако се налазимо у координатном почетку и испред нас је негативна Z оса, а десно позитивна X оса, онда је горе позитивна Y оса.

Свака коцка садржи нула или више објеката. Сваки објекат садржи једну или више особина (назив објекта је такође особина објекта). Из перспективе ботова, објекти се међусобно разликују само по координатама и особинама. То значи да ако два објекта имају исте особине и налазе се у истој коцки, бот неће моћи да их распозна, чак и ако су ти објекти различити из перспективе симулатора (изведени из различите класе, имају различито понашање, итд). Особине објеката су стрингови и то су статички атрибути класе из које је објекат изведен (објекат не може мењати своје особине током времена, постоје други начини да објекат промени своје "стање" тако да други објекти то могу приметити).

Интеракције између ботова и објеката врше се слањем порука. На пример, уколико бот жели да гурне камен (камен је објекат) у страну да би могао да прође одређеним путем, он онда пошаље поруку камену да жели да га гурне и уколико камен "процени" да бот има привилегије да то учини, камен ће се померити у страну. Када кажемо да "процени" да има привилегије, то значи да постоје нека ограничења, као на пример да бот може гурнути камен само уколико је окренут ка камену и уколико се налази у истој хоризонталној равни и уколико је удаљен тачно једну коцку. Други пример је ако бот хоће да сакупи новчић (новчић је објекат), онда бот пошаље поруку новчићу да жели да га сакупи, новчић врши неке провере и ако је све у реду, онда новчић уклони себе из света и увећа број бодова тог бота за своју вредност. Наравно, бот може слати произвољне поруке произвољним објектима, тако да објекат који прими поруку врши провере пре него што изврши тражену акцију.

Ако бот хоће да убије другог бота, он може да му пошаље поруку да жели да га убије (јер је слање порука једини начин интеракције). Овде треба нагласити да се обрада поруке коју објекат (у овом случају бот) прими врши на нивоу симулатора, а не на нивоу корисничке скрипте коју бот извршава. То значи да ако бот прими поруку да други бот (или неки други ентитет) жели да га убије, не одлучује се у корисничкој скрипти да ли ће се то прихватити, већ обраду поруке врши симулатор (у супротном корисничка скрипта би могла да одбаци све такве поруке и ботови би били неуништиви).

Бот може интераговати само са објектима из коцака које може да "види". Сматра се да бот може да види коцку уколико се на путањи од центра коцке у којој се налази бот до бар једне од страна коцке не налази ни један објекат који има особину *"opaque"* (односно да су све коцке на датој путањи или празне или садрже само објекте који су прозрачни). На пример, коцка земље има особину *"opaque"* и кроз њу ботови не могу гледати, односно не могу дохватати информације нити интераговати са други објектима које коцка земље заклања од њих. Са друге стране, дрво је декларисано тако да нема ту особину, па ботови могу гледати "кроз" дрво (јер стабло дрвета заузима мали простор унутар коцке). Треба још напоменути да визуелне компоненте симулатора немају везе са овим о чему смо причали, односно то да ли се неки објекат исцртава прозирно или непрозирно у 3D анимацији не утиче на то да ли ботови кроз њега могу гледати или не. Оно што је ботовима од интереса су формално дефинисане особине објеката.

### ProgLang

#### Опис

Трећи фрејмворк који се користи је фрејмворк за програмске језике. Особине овог фрејмворка су следеће:

* Једноставно и флексибилно креирање нових програмских језика без потребе да се неке техничке ствари сваки пут имплементирају изнова.
* Потпуна контрола извршавања. Неопходно је да извршавање скрипте у одређеном програмском језику буде могуће извршавати уз потпуну контролу алокације меморије, броја инструкција у јединици времена, броја креираних нити, итд.
* Серијализабилност. Пошто смо рекли да је симулатор серијализабилан, онда и стање извршавања корисничке скрипте мора бити серијализабилно.
* Детерминизам. Све скрипте, без обзира на програмски језик у коме су написане, морају да имају потпуно предвидиво и детерминистичко понашање.
* Безбедност. Спречити бесконачне петље и неконтролисану алокацију ресурса од стране корисничких скрипти.
* Итеративна имплементација. Све операције имплементиране су итеративно и стек који скрипте користе је заправо симулирани стек који се налази на хипу. Системски стек се не може преоптеретити неконтролисаним рекурзивним позивима.
* Комбинација микро и макро инструкција. Интерна имплементација доступних функција је флексибилна у погледу сложености атомичних операција. На пример, могуће је у неки програмски језик убацити инструкцију која сортира низ и то ће се сматрати једном инструкцијом, иако је то могло да се уради помоћу великог броја других, мање сложених, инструкција. На имплементацији програмског језика је како ће се обрађивати извршавање инструкције, али неке генералне ствари о којима треба водити рачуна је да свака инструкција треба да има ограничену временску и просторну сложеност (сортирање низа не би била добра инструкција ако низ може бити произвољне величине).
* Обједињени процеси парсирања, компајлирања и интерпретирања кодова. Ова три процеса одвијају се у истом графу извршавања (биће више речи касније о томе), тако да ако настане грешка у било ком од ових процеса, третираће се на идентичан начин. Ово омогућава лакшу имплементацију интерпретативних програмских језика који могу динамички да извршавају кодове представљене стринговима, односно где је потребно покренути парсер динамички за време извршавања скрипте.
* Симулација других програмских језика. Уколико семантика програмског језика то дозвољава, могуће је имплементирати посебну функционалност унутар самог програмског језика која креира "виртуелну машину" у којој потом симулира било који од доступних имплементираних програмских језика, препуштајући виртуелној машини исту или мању количину ресурса од количине ресурса којом располаже сама скрипта. Ово, наравно, дозвољава и угнежђивање виртуелних машина, све до границе доступне количине меморије која је додељена корисничкој скрипти.
* Сваки програмски језик поседује три тока података, а то су улазни, излазни и ток података за грешке. Грануларност ових токова података омогућава упис и читање појединачних битова, а уколико се комбинују битови и бајтови, онда се битови уносе у реверзном поретку у односу на запис бајта у бинарном облику.

#### Имплементација

Имплементација нових програмских језика врши се у три фазе:

1. Дефинисати синтаксу и написати синтаксичке дефиниције у формалној синтаксној нотацији. Синтаксна нотација која се користи је слична као EBNF, али је *"context-aware"*, односно могуће је динамички мењати глобалне флегове који утичи на парсирање појединих делова кода. Треба напоменути да парсирање није део имплементације програмског језика - све што је потребно урадити је написати синтаксичке дефиниције, а фрејмворк ће искористити те дефиниције за парсирање корисничке скрипте. Резултат парсирања је апстрактно синтаксно стабло (AST).
2. Написати компајлер који представља мапирање чворова AST у функције које обрађују сваки чвор појединачно. За сваку синтаксичку дефиницију енумеришу се сви чворови AST који тој дефиницији одговарају и врши се припрема тих чворова за процес интерпретирања. Резултат компајлера је граф извршавања спреман за интепретирање.
3. Имплементирати интерпретер који трансформише граф извршавања у зависности од чвора графа који је декларисан као врх стека. Постоје статички и динамички чворови графа. Статички (операнди) поседују податке и не смеју се наћи на стеку, а динамички (операције) представљају *"stack frame"*-ове који су повезани у уланчану листу.

#### Граф извршавања

Виртуелна меморија није представљена низом бајтова, већ усмереним графом. Сваки од чворова графа поседује ефективну величину и перзистентност. Ефективна величина је број који би требало да буде приближно сразмеран броју бајтова које тај чвор физички заузима у меморији (овде је узето да буде сваки атрибут 8 бајтова плус величина самог атрибута, бројеви: 8 бајтова, стрингови: број карактера у стрингу, итд). Перзистентност је флег који означава да ли тај чвор сме бити деалоциран уколико нема референци на њега. Прецизније, уколико не постоји путања од неког перзистентног чвора до датог чвора, он ће бити деалоциран. Деалокација сувишних чворова врши се позивом *"Garbage collector"*-а. Ову функцију позива симулатор када доће до преоптерећења меморије. Уколико се ни један чвор не деалоцира, а меморија је и даље преоптерећена, корисничка скрипта ће бити заустављена и ресурси ослобођени.

Осим величине и перзистентности, чвор може поседовати и интерне референце, екстерне референце и скаларна поља. Интерне референце су референце на чворове истог графа. Њих није потребно серијализовати из класе чвора, већ њих серијализује сам граф. Екстерне референце су референце на објекте који нису део графа (то могу бити чворови другог графа или било који други објекти у меморији). Њих није могуће серијализовати из класе графа, већ њих мора да серијализује класа која је креирала граф, а при десеријализацији графу морају бити прослеђене референце на идентичне екстерне објекте у идентичном редоследу да би они могли бити исправно повезани. Чвор може поседовати и скаларна поља (бројеве, карактере, стрингове, итд) и о њима граф не води евиденцију, већ сам чвор мора да серијализује и десеријализује та поља.

Фрејмворк за програмске језике поседује само један перзистентан чвор у графу извршавања, а то је интерпретер. Интепретер поседује скуп нити, свака нит има свој стек, а на стеку се налазе динамички чворови графа. Интепретер, нит и стек су чворови графа. У свакој инструкцији интепретер одабере одређену нит по тачно дефинисаним правилима (ако програм има само једну нит онда бира ту једну нит, ако нема ни једну нит онда се програм завршава). Изабрана нит потом позива методу динамичког чвора са врха стека која је задужена за извршавање одређене трансформације графа. Та метода може да алоцира нове ресурсе, да угаси нит, да "позове" други динамички чвор (позив се врши слањем сигнала нити и тек у следећој инструкцији ће позив бити обављен), да врати одређени статички чвор као резултат (и то се врши слањем сигнала нити, овај динамички чвор ће бити скинут са стека и у претходни чвор ће се уписати повратна вредност, а извршавање тог динамичког чвора који је доспео на врх стека се наставља тек у следећој инструкцији), да баци грешку (грешке су статички чворови који садрже информације о поруци, стеку и локацији у коду где је грешка настала), итд.

## Корисничка скрипта

Без обзира у ком програмском језику је скрипта написана, интеракција са окружењем се врши на идентичан начин - преко улазних и излазних токова података. Захтев за извршењем одређене акције врши се исписом на стандардни излаз, а дохватање информација из окружења врши се читањем са стандардног улаза. Симулатор не води рачуна о томе у ком програмском језику је скрипта написана, она се извршава независно, а симулатор само интерагује са интерфејсом представљеним токовима података корисничке скрипте. Овде треба напоменути да се под појмовима стандардног улаза и излаза, као и тока података за грешке подразумевају виртуелни токови података који се налазе у самом симулатору. То нису токови података конзолне апликације, већ само бафери у оперативној меморији.

### Подразумевани програмски језик

Подразумевани програмски језик за корисничке скрипте (програмски језик који је иницијално подешен у сандбоксу) је [Functional()](https://esolangs.org/wiki/Functional()). То је *"Turing complete"* езотерични програмски језик функционалне парадигме. Он је идеалан за потребе овог симулатора и прилично је једноставно направити интерпретер за њега. Осим девет стандардних функција које су дефинисане спецификацијом, уведена је и десета функција, која није неопходна, али знатно олакшава и убрзава писање скрипти. Првих девет функција је детаљно објашњено у спецификацији и нећемо их овде описивати, већ ћемо само навести особине десете функције. *"Functional()"* има ту особина да првих девет (у нашем случају десет) идентификатора који се појаве у скрипти попримају вредност девет (односно десет) уграђених функција. Када отворите сандбокс видећете пример једноставне скрипте помоћу које бот трага за новчићима и заобилази препреке. Та скрипта почиње следећим кодом:

```
0, 1, ==, =, var, [],
in, out, eof, #
```

Ово су првих десет идентификатора. Десети идентификатор означен је знаком `#`. У *"Functional()"*-у не постоје класе ни методи, већ се све врши позивима функција. Због тога, да бисмо приступили методама објекта `#`, морамо назив метода проследити као аргумент. На пример, ако хоћемо да дохватимо референцу на тренутну коцку у којој се налазимо, извршићемо следећи код:

```
# .get(# 0, # 0, # 0)
```

Овде имамо идентификаторе `#` и `.get` који се налазе један поред другог раздвојени бланко знаком. Према спецификацији овог програмског језика, `a b` се сматра синтаксички еквивалентним као `a(b)`, па се ово може сматрати прослеђивањем аргумента `.get` функцији `#` (треба нагласити да је `#` ефективно објекат, али је формално само функција). Функција `#` ће то препознати као метод и вратиће одговарајућу функцију као резултат. Даље ту функцију позивамо са три аргумента `# 0, # 0, # 0`. Када `#` позовемо са аргументом који се синтаксички представља као број, онда ће вратити референцу на новоалоциран број са датом вредношћу. Дакле, овај код дохвата коцку са координатама (0, 0, 0) релативно у односу на бота. Овде треба водити рачуна о неколико ствари. Прво, уколико бот не може да види дату коцку, ова функција враћа `null`, па се мора извршити провера пре него што се нешто уради са овом коцком (наравно, у овом конкретном случају то није могуће да се деси, јер бот увек може да види сопствену коцку, али генерално може да се деси да неку коцку не може да види). Друга ствар о којој треба водити рачуна је да оваква референца није поуздана, у смислу да она губи смисао након што се бот помери. Референца ће након померања бота показивати на другу коцку. Такође, ако се референца не искористи у истом фрејму, већ у следећем фрејму може да се деси да се неки објекат препречи и заклони ту коцку од бота, тако да приступ тој коцки може да баци грешку. Референце треба искористити само у истом фрејму у ком су дохваћене.

Да бисмо нешто корисно урадили са референцом на коцку, требало би да је сачувамо у неку променљиву. Креирање нове променљиве врши се позивом функције `var`. У следећем примеру дохватићемо коцку која је директно испред нас (координате (0, 0, -1)) и сачуваћемо је у променљиву `block`

```
var(block, # .get(# 0, # 0, # -1))
```

Не морамо да проверавамо да ли видимо коцку или не, свакако је видимо јер је одмах испред нас. Сада желимо, на пример, да дохватимо први објекат у тој коцки који има особину *"pushable"* и да референцу на тај објекат сачувамо у променљиву `obj` (водити рачуна да иза сваке линије кода осим последње мора да стоји зарез, али овде то не пишемо ради прегледности):

```
var(obj, block .get(# "pushable"))
```

Уколико се у датој коцки не налази објекат са особином *"pushable"*, променљива `obj` ће имати вредност `null`. Због тога неопходно је извршити проверу. Провера се врши тако што помоћу функције `==` проверимо да ли је дати објекат једнак `null`, ако јесте онда не радимо ништа (или можемо неку другу акцију предузети), а ако није онда ћемо послати том објекту поруку *"push"* чиме ћемо покушати да гурнемо тај објекат у правцу у ком смо окренути. Функција `==` прима два аргумента и враћа `1` или `0` уколико су аргументи једнаки или различити, респективно. Овде је веома битно напоменути да ово нису бројеви `1` и `0` који се могу користити као координате, већ су ово глобалне функције `1` и `0` које имају сасвим другачију сврху (односно `0` и `# 0` немају ништа заједничко, само су синтаксички сличне конструкције). Глобална функција `0` прима два аргумента и враћа други аргумент, глобална функција `1` прима два аргумента и враћа први аргумент. Глобална функција `[]` служи за креирање нове функције. Ово све ћемо искористити да извршимо неопходну проверу:

```
==(obj, # .null)(0, []()(
  obj .send(# "push")
))()
```

На овај начин смо извршили гурање објекта уколико тај објекат може да се гурне. Резултат операције `send` такође можемо даље да проверавамо да утврдимо да ли је објекат успешно гурнут или не. Све што функција `#` и њене методе раде у позадини је исписивање података на стандардни излаз и читање података са стандардног улаза. Све то је могуће урадити и коришћењем првих девет глобалних функција (чак првих осам, јер девета у симулатору увек враћа `0`). Референце о којима овде говоримо нису никакве екстерне референце, већ само обични објекти који памте координате и особине објеката које референцирају. То нема везе са симулатором, већ служи за стварање вишег нивоа апстракције у погледу интеракције са другим објектима (слично као креирање новог објекта у PHP-у који референцира садржај дохваћен из базе, ми радимо са објектом, али се база не мења све док то не сачувамо).

Још једна веома битна ствар коју на крају треба напоменути је да корисничка скрипта мора да се врти у одређеној петљи, у супротном скрипта се завршава и то се сматра одустајањем од даљег такмичења. У *"Functional()"*-у не постоје петље, већ то мора да се реализује рекурзивним позивима:

```
var(loop, []()(
  // do some stuff,

  # .dispatch(),
  loop()
))()
```

Овде креирамо променљиву `loop` (и одмах је позивамо) којој придружујемо функцију која ради неке ствари, затим позива `dispatch`, а затим рекурзивно позива `loop`. Веома је битно позвати `dispatch`, јер у сваком фрејму постоји максималан број инструкција које корисничка скрипта може да изврши. Уколико прекорачи тај број, извршавање скрипте се паузира до следећег фрејма. Проблем са тим је што онда скрипта не може да зна када ће бити прекинута и уколико дереференцира неку коцку или објекат дохваћен у претходном фрејму може да настане грешка и да скрипта буде убијена од стране симулатора. Функција `dispatch` паузира скрипту до следећег фрејма, а у следећем фрејму се број инструкција ресетује, тако да уколико се у самој петљи не прекорачи дозвољен број инструкција, не могу настати никакви други проблеми. Још треба напоменути да рекурзивни позив `loop` у свакој итерацији није никакав проблем, јер фрејмворк за програмске језике аутоматски врши [Tail call optimization](https://en.wikipedia.org/wiki/Tail_call) механизам за детекцију *"stack frame"*-ова који су непотребни и избацује их са стека, тако да меморија не расте.

Методи `go`, `rotate` и `send` објекта `#` имају исти ефекат као `dispatch` уколико је захтевана операције извршена успешно. Треба водити евиденцију о успешности операције и у зависности од тога прескочити позив `dispatch` у одређеној итерацији, јер ће у супротном скрипта прескакати сваки други фрејм (бот неће радити ништа у сваком другом фрејму).